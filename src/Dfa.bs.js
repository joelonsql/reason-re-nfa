// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE

import * as $$Map from "../node_modules/bs-platform/lib/es6/map.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Int32 from "../node_modules/bs-platform/lib/es6/int32.js";
import * as Hashtbl from "../node_modules/bs-platform/lib/es6/hashtbl.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";
import * as StateSet$ReasonReNfa from "./StateSet.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as CharMapStateSet$ReasonReNfa from "./CharMapStateSet.bs.js";

var StateMap = $$Map.Make([Int32.compare]);

function charmap_union(f) {
  return Curry._1(CharMapStateSet$ReasonReNfa.merge, (function (k, x, y) {
                if (x !== undefined) {
                  var v = Caml_option.valFromOption(x);
                  if (y !== undefined) {
                    return Curry._3(f, k, v, Caml_option.valFromOption(y));
                  } else {
                    return Caml_option.some(v);
                  }
                } else if (y !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(y));
                } else {
                  return undefined;
                }
              }));
}

function fold_states(f, dfa, init) {
  var v = /* record */[/* contents */init];
  var seen = Hashtbl.create(undefined, 10);
  var visit = function (state) {
    if (Hashtbl.mem(seen, state)) {
      return 0;
    } else {
      v[0] = Curry._2(f, state, v[0]);
      Hashtbl.add(seen, state, /* () */0);
      return Curry._2(CharMapStateSet$ReasonReNfa.iter, (function (param) {
                    return visit;
                  }), Curry._1(dfa[/* next */2], state));
    }
  };
  visit(dfa[/* start */0]);
  return v[0];
}

function fold_transitions(f, dfa, init) {
  return fold_states((function (src, v) {
                return Curry._3(CharMapStateSet$ReasonReNfa.fold, (function (c, dst) {
                              return Curry._1(f, /* tuple */[
                                          src,
                                          c,
                                          dst
                                        ]);
                            }), Curry._1(dfa[/* next */2], src), v);
              }), dfa, init);
}

function add_transition(param, trans) {
  var dst = param[2];
  var c = param[1];
  var src = param[0];
  var exit = 0;
  var cm;
  try {
    cm = Curry._2(StateMap[/* find */21], src, trans);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(StateMap[/* add */3], src, Curry._2(CharMapStateSet$ReasonReNfa.singleton, c, dst), trans);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return Curry._3(StateMap[/* add */3], src, Curry._3(CharMapStateSet$ReasonReNfa.add, c, dst, cm), trans);
  }
  
}

function add_transition$prime(param, trans) {
  var dst = param[2];
  var c = param[1];
  var src = param[0];
  var exit = 0;
  var cm;
  try {
    cm = Curry._2(StateMap[/* find */21], src, trans);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Curry._3(StateMap[/* add */3], src, Curry._2(CharMapStateSet$ReasonReNfa.singleton, c, Curry._1(StateSet$ReasonReNfa.singleton, dst)), trans);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    var dstset;
    var exit$1 = 0;
    var dstset$1;
    try {
      dstset$1 = Curry._2(CharMapStateSet$ReasonReNfa.find, c, cm);
      exit$1 = 2;
    }
    catch (exn$1){
      if (exn$1 === Caml_builtin_exceptions.not_found) {
        dstset = Curry._1(StateSet$ReasonReNfa.singleton, dst);
      } else {
        throw exn$1;
      }
    }
    if (exit$1 === 2) {
      dstset = Curry._2(StateSet$ReasonReNfa.add, dst, dstset$1);
    }
    return Curry._3(StateMap[/* add */3], src, Curry._3(CharMapStateSet$ReasonReNfa.add, c, dstset, cm), trans);
  }
  
}

function reverse(dfa) {
  var map = fold_transitions((function (param) {
          var partial_arg_000 = param[2];
          var partial_arg_001 = param[1];
          var partial_arg_002 = param[0];
          var partial_arg = /* tuple */[
            partial_arg_000,
            partial_arg_001,
            partial_arg_002
          ];
          return (function (param) {
              return add_transition$prime(partial_arg, param);
            });
        }), dfa, StateMap[/* empty */0]);
  return /* record */[
          /* start */dfa[/* finals */1],
          /* finals */Curry._1(StateSet$ReasonReNfa.singleton, dfa[/* start */0]),
          /* next */(function (s) {
              try {
                return Curry._2(StateMap[/* find */21], s, map);
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return CharMapStateSet$ReasonReNfa.empty;
                } else {
                  throw exn;
                }
              }
            })
        ];
}

function transitions(states, nfa) {
  return Curry._3(StateSet$ReasonReNfa.fold, (function (s, m) {
                var m$prime = Curry._1(nfa[/* next */2], s);
                return Curry._2(charmap_union((function (param, s, s$prime) {
                                  return Caml_option.some(Curry._2(StateSet$ReasonReNfa.union, s, s$prime));
                                })), m, m$prime);
              }), states, CharMapStateSet$ReasonReNfa.empty);
}

var M = $$Map.Make([StateSet$ReasonReNfa.compare]);

function determinize(nfa) {
  var r = /* record */[/* contents */0];
  var fresh = function (param) {
    r[0] = Int32.succ(r[0]);
    return r[0];
  };
  var build = function (states, param) {
    var finals = param[2];
    var ts = param[1];
    var map = param[0];
    var exit = 0;
    var state;
    try {
      state = Curry._2(M[/* find */21], states, map);
      exit = 1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var state$1 = fresh(/* () */0);
        var finals$1 = Curry._1(StateSet$ReasonReNfa.is_empty, Curry._2(StateSet$ReasonReNfa.inter, states, nfa[/* finals */1])) ? finals : Curry._2(StateSet$ReasonReNfa.add, state$1, finals);
        var map$1 = Curry._3(M[/* add */3], states, state$1, map);
        var tsn = transitions(states, nfa);
        var match = Curry._3(CharMapStateSet$ReasonReNfa.fold, (function (c, ss, param) {
                var match = build(ss, /* tuple */[
                      param[0],
                      param[1],
                      param[2]
                    ]);
                var ts = add_transition(/* tuple */[
                      state$1,
                      c,
                      match[0]
                    ], match[2]);
                return /* tuple */[
                        match[1],
                        ts,
                        match[3]
                      ];
              }), tsn, /* tuple */[
              map$1,
              ts,
              finals$1
            ]);
        return /* tuple */[
                state$1,
                match[0],
                match[1],
                match[2]
              ];
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* tuple */[
              state,
              map,
              ts,
              finals
            ];
    }
    
  };
  var match = build(nfa[/* start */0], /* tuple */[
        M[/* empty */0],
        StateMap[/* empty */0],
        StateSet$ReasonReNfa.empty
      ]);
  var trans = match[2];
  var next = function (s) {
    try {
      return Curry._2(StateMap[/* find */21], s, trans);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return CharMapStateSet$ReasonReNfa.empty;
      } else {
        throw exn;
      }
    }
  };
  return /* record */[
          /* start */match[0],
          /* finals */match[3],
          /* next */next
        ];
}

function minimize(g) {
  return determinize(reverse(determinize(reverse(g))));
}

function inject(param) {
  var next = param[/* next */2];
  return /* record */[
          /* start */Curry._1(StateSet$ReasonReNfa.singleton, param[/* start */0]),
          /* finals */param[/* finals */1],
          /* next */(function (s) {
              return Curry._2(CharMapStateSet$ReasonReNfa.map, StateSet$ReasonReNfa.singleton, Curry._1(next, s));
            })
        ];
}

function accept(dfa, inp) {
  var _cur = dfa[/* start */0];
  var _param = inp;
  while(true) {
    var param = _param;
    var cur = _cur;
    if (param) {
      var exit = 0;
      var s;
      try {
        s = Curry._2(CharMapStateSet$ReasonReNfa.find, param[0], Curry._1(dfa[/* next */2], cur));
        exit = 1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return false;
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        _param = param[1];
        _cur = s;
        continue ;
      }
      
    } else {
      return Curry._2(StateSet$ReasonReNfa.mem, cur, dfa[/* finals */1]);
    }
  };
}

export {
  StateMap ,
  charmap_union ,
  fold_states ,
  fold_transitions ,
  add_transition ,
  add_transition$prime ,
  reverse ,
  transitions ,
  determinize ,
  minimize ,
  inject ,
  accept ,
  
}
/* StateMap Not a pure module */
