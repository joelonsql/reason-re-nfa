// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE

import * as $$Set from "../node_modules/bs-platform/lib/es6/set.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_obj from "../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Letter$ReasonReNfa from "./Letter.bs.js";
import * as LetterSet$ReasonReNfa from "./LetterSet.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

function compare(param, param$1) {
  return Caml_obj.caml_compare(/* tuple */[
              param[0][1],
              param[1][1]
            ], /* tuple */[
              param$1[0][1],
              param$1[1][1]
            ]);
}

var Pair = /* module */[/* compare */compare];

var S = $$Set.Make(Pair);

var $less$plus$great = S[/* union */6];

function $great$great$eq(m, k) {
  return Curry._3(LetterSet$ReasonReNfa.S[/* fold */13], (function (x, s) {
                return Curry._2($less$plus$great, Curry._1(k, x), s);
              }), m, S[/* empty */0]);
}

function $less$star$great(l, r) {
  return $great$great$eq(l, (function (x) {
                return $great$great$eq(r, (function (y) {
                              return Curry._1(S[/* singleton */4], /* tuple */[
                                          x,
                                          y
                                        ]);
                            }));
              }));
}

function to_string(l2s) {
  return $$String.concat(" ", List.rev(Curry._3(S[/* fold */13], (function (param, l) {
                        return /* :: */[
                                Letter$ReasonReNfa.to_string(param[0]) + Letter$ReasonReNfa.to_string(param[1]),
                                l
                              ];
                      }), l2s, /* [] */0)));
}

function example(letter1, letter2) {
  return Curry._1(S[/* singleton */4], /* tuple */[
              letter1,
              letter2
            ]);
}

function test(param) {
  var abc = example(Letter$ReasonReNfa.example(/* :: */[
            /* "a" */97,
            /* [] */0
          ], 0), Letter$ReasonReNfa.example(/* :: */[
            /* "b" */98,
            /* :: */[
              /* "c" */99,
              /* [] */0
            ]
          ], 1));
  if (to_string(abc) !== "a<sub>0</sub>{b c}<sub>1</sub>") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Letter2Set.re",
            42,
            2
          ]
        ];
  }
  var a = LetterSet$ReasonReNfa.example(/* :: */[
        /* "a" */97,
        /* [] */0
      ], 0);
  var bc = LetterSet$ReasonReNfa.example(/* :: */[
        /* "b" */98,
        /* :: */[
          /* "c" */99,
          /* [] */0
        ]
      ], 1);
  var abc$prime = $less$star$great(a, bc);
  if (!Caml_obj.caml_equal(abc, abc$prime)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Letter2Set.re",
            46,
            2
          ]
        ];
  }
  var abc$prime$prime = $great$great$eq(a, (function (x) {
          return $great$great$eq(bc, (function (y) {
                        return Curry._1(S[/* singleton */4], /* tuple */[
                                    x,
                                    y
                                  ]);
                      }));
        }));
  if (Caml_obj.caml_equal(abc, abc$prime$prime)) {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Letter2Set.re",
            48,
            2
          ]
        ];
  }
}

export {
  Pair ,
  S ,
  $less$plus$great ,
  $great$great$eq ,
  $less$star$great ,
  to_string ,
  example ,
  test ,
  
}
/* S Not a pure module */
