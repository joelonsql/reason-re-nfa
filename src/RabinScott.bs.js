// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Int32 from "../node_modules/bs-platform/lib/es6/int32.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";
import * as Dfa$ReasonReNfa from "./Dfa.bs.js";
import * as StateSet$ReasonReNfa from "./StateSet.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as CharMapStateSet$ReasonReNfa from "./CharMapStateSet.bs.js";
import * as StateSetMapState$ReasonReNfa from "./StateSetMapState.bs.js";
import * as StateMapCharMapStateSet$ReasonReNfa from "./StateMapCharMapStateSet.bs.js";

function transitions(states, nfa) {
  return Curry._3(StateSet$ReasonReNfa.fold, (function (s, m) {
                var m$prime = Curry._1(nfa[/* next */2], s);
                return Curry._2(CharMapStateSet$ReasonReNfa.union((function (param, s, s$prime) {
                                  return Caml_option.some(Curry._2(StateSet$ReasonReNfa.union, s, s$prime));
                                })), m, m$prime);
              }), states, CharMapStateSet$ReasonReNfa.empty);
}

function determinize(nfa) {
  var r = /* record */[/* contents */0];
  var fresh = function (param) {
    r[0] = Int32.succ(r[0]);
    return r[0];
  };
  var build = function (states, param) {
    var finals = param[2];
    var ts = param[1];
    var map = param[0];
    var exit = 0;
    var state;
    try {
      state = Curry._2(StateSetMapState$ReasonReNfa.find, states, map);
      exit = 1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        var state$1 = fresh(/* () */0);
        var finals$1 = Curry._1(StateSet$ReasonReNfa.is_empty, Curry._2(StateSet$ReasonReNfa.inter, states, nfa[/* finals */1])) ? finals : Curry._2(StateSet$ReasonReNfa.add, state$1, finals);
        var map$1 = Curry._3(StateSetMapState$ReasonReNfa.add, states, state$1, map);
        var match = Curry._3(CharMapStateSet$ReasonReNfa.fold, (function (c, ss, param) {
                var match = build(ss, /* tuple */[
                      param[0],
                      param[1],
                      param[2]
                    ]);
                var ts = Dfa$ReasonReNfa.add_transition(/* tuple */[
                      state$1,
                      c,
                      match[0]
                    ], match[2]);
                return /* tuple */[
                        match[1],
                        ts,
                        match[3]
                      ];
              }), transitions(states, nfa), /* tuple */[
              map$1,
              ts,
              finals$1
            ]);
        return /* tuple */[
                state$1,
                match[0],
                match[1],
                match[2]
              ];
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* tuple */[
              state,
              map,
              ts,
              finals
            ];
    }
    
  };
  var match = build(nfa[/* start */0], /* tuple */[
        StateSetMapState$ReasonReNfa.empty,
        StateMapCharMapStateSet$ReasonReNfa.empty,
        StateSet$ReasonReNfa.empty
      ]);
  var trans = match[2];
  var next = function (s) {
    try {
      return Curry._2(StateMapCharMapStateSet$ReasonReNfa.find, s, trans);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return CharMapStateSet$ReasonReNfa.empty;
      } else {
        throw exn;
      }
    }
  };
  return /* record */[
          /* start */match[0],
          /* finals */match[3],
          /* next */next
        ];
}

export {
  transitions ,
  determinize ,
  
}
/* Dfa-ReasonReNfa Not a pure module */
