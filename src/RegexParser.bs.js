// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE

import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_exceptions from "../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Regex$ReasonReNfa from "./Regex.bs.js";

var Parse_error = Caml_exceptions.create("RegexParser-ReasonReNfa.Parse_error");

var Fail = Caml_exceptions.create("RegexParser-ReasonReNfa.Fail");

function re_parse_atom(param) {
  if (param) {
    var h = param[0];
    var exit = 0;
    var switcher = h - 63 | 0;
    if (switcher > 61 || switcher < 0) {
      switch (switcher) {
        case -23 : 
            var match = re_parse_alt(param[1]);
            var match$1 = match[1];
            if (match$1) {
              if (match$1[0] !== 41) {
                throw Fail;
              } else {
                return /* tuple */[
                        match[0],
                        match$1[1]
                      ];
              }
            } else {
              throw Fail;
            }
        case -22 : 
        case -21 : 
        case -20 : 
            return undefined;
        case -19 : 
        case -18 : 
            exit = 1;
            break;
        case -17 : 
            return /* tuple */[
                    Regex$ReasonReNfa.any,
                    param[1]
                  ];
        default:
          exit = 1;
      }
    } else if (switcher > 60 || switcher < 1) {
      return undefined;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              Regex$ReasonReNfa.chr(h),
              param[1]
            ];
    }
    
  }
  
}

function re_parse_suffixed(char_list) {
  var match = re_parse_atom(char_list);
  if (match !== undefined) {
    var match$1 = match;
    var rest = match$1[1];
    var r = match$1[0];
    if (rest) {
      var switcher = rest[0] - 42 | 0;
      if (switcher === 0 || switcher === 1) {
        if (switcher !== 0) {
          return /* tuple */[
                  Regex$ReasonReNfa.plus(r),
                  rest[1]
                ];
        } else {
          return /* tuple */[
                  Regex$ReasonReNfa.star(r),
                  rest[1]
                ];
        }
      } else if (switcher !== 21) {
        return /* tuple */[
                r,
                rest
              ];
      } else {
        return /* tuple */[
                Regex$ReasonReNfa.opt(r),
                rest[1]
              ];
      }
    } else {
      return /* tuple */[
              r,
              rest
            ];
    }
  }
  
}

function re_parse_seq(char_list) {
  var match = re_parse_suffixed(char_list);
  if (match !== undefined) {
    var match$1 = match;
    var match$2 = re_parse_seq(match$1[1]);
    return /* tuple */[
            Regex$ReasonReNfa.seq(match$1[0], match$2[0]),
            match$2[1]
          ];
  } else {
    return /* tuple */[
            Regex$ReasonReNfa.eps,
            char_list
          ];
  }
}

function re_parse_alt(char_list) {
  var match = re_parse_seq(char_list);
  var rest = match[1];
  var r = match[0];
  if (rest && rest[0] === 124) {
    var match$1 = re_parse_alt(rest[1]);
    return /* tuple */[
            Regex$ReasonReNfa.alt(r, match$1[0]),
            match$1[1]
          ];
  } else {
    return /* tuple */[
            r,
            rest
          ];
  }
}

function explode(regex) {
  var _i = regex.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(regex, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function parse(regex) {
  var exit = 0;
  var val;
  try {
    val = re_parse_alt(explode(regex));
    exit = 1;
  }
  catch (exn){
    if (exn === Fail) {
      throw [
            Parse_error,
            regex
          ];
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (val[1]) {
      throw [
            Parse_error,
            regex
          ];
    } else {
      return val[0];
    }
  }
  
}

export {
  Parse_error ,
  Fail ,
  re_parse_atom ,
  re_parse_suffixed ,
  re_parse_seq ,
  re_parse_alt ,
  explode ,
  parse ,
  
}
/* Regex-ReasonReNfa Not a pure module */
