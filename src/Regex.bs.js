// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE

import * as $$Map from "../node_modules/bs-platform/lib/es6/map.js";
import * as $$Set from "../node_modules/bs-platform/lib/es6/set.js";
import * as Char from "../node_modules/bs-platform/lib/es6/char.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Int32 from "../node_modules/bs-platform/lib/es6/int32.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_obj from "../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_exceptions from "../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Nfa$ReasonReNfa from "./Nfa.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

var C = $$Set.Make([Char.compare]);

function compare(param, param$1) {
  return Caml_obj.caml_compare(param[1], param$1[1]);
}

var Letter = /* module */[/* compare */compare];

var S = $$Set.Make(Letter);

var $less$plus$great = S[/* union */6];

var LetterSet = /* module */[
  /* S */S,
  /* <+> */$less$plus$great
];

function compare$1(param, param$1) {
  return Caml_obj.caml_compare(/* tuple */[
              param[0][1],
              param[1][1]
            ], /* tuple */[
              param$1[0][1],
              param$1[1][1]
            ]);
}

var Pair = /* module */[/* compare */compare$1];

var S$1 = $$Set.Make(Pair);

var $less$plus$great$1 = S$1[/* union */6];

function $great$great$eq(m, k) {
  return Curry._3(S[/* fold */13], (function (x, s) {
                return Curry._2($less$plus$great$1, Curry._1(k, x), s);
              }), m, S$1[/* empty */0]);
}

function $less$star$great(l, r) {
  return $great$great$eq(l, (function (x) {
                return $great$great$eq(r, (function (y) {
                              return Curry._1(S$1[/* singleton */4], /* tuple */[
                                          x,
                                          y
                                        ]);
                            }));
              }));
}

var Letter2Set = /* module */[
  /* Pair */Pair,
  /* S */S$1,
  /* <+> */$less$plus$great$1,
  /* >>= */$great$great$eq,
  /* <*> */$less$star$great
];

function l(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param === 0) {
        return false;
      } else {
        return true;
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return false;
        case 1 : 
            if (l(param[0])) {
              return true;
            } else {
              _param = param[1];
              continue ;
            }
        case 2 : 
            if (l(param[0])) {
              _param = param[1];
              continue ;
            } else {
              return false;
            }
        case 3 : 
            return true;
        
      }
    }
  };
}

function p(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return S[/* empty */0];
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return Curry._1(S[/* singleton */4], param[0]);
        case 1 : 
            return Curry._2($less$plus$great, p(param[0]), p(param[1]));
        case 2 : 
            var e = param[0];
            return Curry._2($less$plus$great, p(e), l(e) ? p(param[1]) : S[/* empty */0]);
        case 3 : 
            _param = param[0];
            continue ;
        
      }
    }
  };
}

function d(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return S[/* empty */0];
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return Curry._1(S[/* singleton */4], param[0]);
        case 1 : 
            return Curry._2($less$plus$great, d(param[0]), d(param[1]));
        case 2 : 
            var e = param[1];
            return Curry._2($less$plus$great, l(e) ? d(param[0]) : S[/* empty */0], d(e));
        case 3 : 
            _param = param[0];
            continue ;
        
      }
    }
  };
}

function f_(param) {
  if (typeof param === "number") {
    return S$1[/* empty */0];
  } else {
    switch (param.tag | 0) {
      case 1 : 
          return Curry._2($less$plus$great$1, f_(param[0]), f_(param[1]));
      case 2 : 
          var f = param[1];
          var e = param[0];
          return Curry._2($less$plus$great$1, Curry._2($less$plus$great$1, f_(e), f_(f)), $less$star$great(d(e), p(f)));
      case 3 : 
          var e$1 = param[0];
          return Curry._2($less$plus$great$1, f_(e$1), $less$star$great(d(e$1), p(e$1)));
      default:
        return S$1[/* empty */0];
    }
  }
}

var StateMap = $$Map.Make([Int32.compare]);

var CharSetMap = $$Map.Make([C[9]]);

function add_transition2(c, i, tm) {
  var ss;
  try {
    ss = Curry._2(CharSetMap[/* find */21], c, tm);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      ss = Nfa$ReasonReNfa.StateSet[/* empty */0];
    } else {
      throw exn;
    }
  }
  return Curry._3(CharSetMap[/* add */3], c, Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], i, ss), tm);
}

function add_transition(i1, c2, i2, sm) {
  var tm;
  try {
    tm = Curry._2(StateMap[/* find */21], i1, sm);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      tm = CharSetMap[/* empty */0];
    } else {
      throw exn;
    }
  }
  return Curry._3(StateMap[/* add */3], i1, add_transition2(c2, i2, tm), sm);
}

function transition_map_of_factor_set(fs) {
  return Curry._3(S$1[/* fold */13], (function (param, sm) {
                var match = param[1];
                return add_transition(param[0][1], match[0], match[1], sm);
              }), fs, StateMap[/* empty */0]);
}

function positions(s) {
  return Curry._1(Nfa$ReasonReNfa.StateSet[/* of_list */25], List.map((function (prim) {
                    return prim[1];
                  }), Curry._1(S[/* elements */19], s)));
}

function transition_map_of_letter_set(s) {
  return Curry._3(S[/* fold */13], (function (param, tm) {
                var i = param[1];
                var c = param[0];
                var entry;
                var exit = 0;
                var s;
                try {
                  s = Curry._2(CharSetMap[/* find */21], c, tm);
                  exit = 1;
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    entry = Curry._1(Nfa$ReasonReNfa.StateSet[/* singleton */4], i);
                  } else {
                    throw exn;
                  }
                }
                if (exit === 1) {
                  entry = Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], i, s);
                }
                return Curry._3(CharSetMap[/* add */3], c, entry, tm);
              }), s, CharSetMap[/* empty */0]);
}

var counter = /* record */[/* contents */0];

function incr32(r) {
  r[0] = Int32.succ(r[0]);
  return /* () */0;
}

function fresh_state(param) {
  var c = counter[0];
  incr32(counter);
  return c;
}

var start_state = fresh_state(/* () */0);

function annotate(param) {
  if (typeof param === "number") {
    if (param === 0) {
      return /* Empty */0;
    } else {
      return /* Eps */1;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var p_000 = param[0];
          var p_001 = fresh_state(/* () */0);
          var p = /* tuple */[
            p_000,
            p_001
          ];
          return /* Char */Block.__(0, [p]);
      case 1 : 
          return /* Alt */Block.__(1, [
                    annotate(param[0]),
                    annotate(param[1])
                  ]);
      case 2 : 
          return /* Seq */Block.__(2, [
                    annotate(param[0]),
                    annotate(param[1])
                  ]);
      case 3 : 
          return /* Star */Block.__(3, [annotate(param[0])]);
      
    }
  }
}

function flatten_transitions(cm) {
  return Curry._3(CharSetMap[/* fold */10], (function (cs, ss, cm) {
                return Curry._3(C[/* fold */13], (function (c, cm) {
                              var entry;
                              try {
                                entry = Curry._2(Nfa$ReasonReNfa.CharMap[/* find */21], c, cm);
                              }
                              catch (exn){
                                if (exn === Caml_builtin_exceptions.not_found) {
                                  entry = Nfa$ReasonReNfa.StateSet[/* empty */0];
                                } else {
                                  throw exn;
                                }
                              }
                              return Curry._3(Nfa$ReasonReNfa.CharMap[/* add */3], c, Curry._2(Nfa$ReasonReNfa.StateSet[/* union */6], ss, entry), cm);
                            }), cs, cm);
              }), cm, Nfa$ReasonReNfa.CharMap[/* empty */0]);
}

function compile(r) {
  var r$1 = annotate(r);
  var finals = l(r$1) ? Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], start_state, positions(d(r$1))) : positions(d(r$1));
  var transitions = transition_map_of_factor_set(f_(r$1));
  var initial_transitions = transition_map_of_letter_set(p(r$1));
  var joint_transitions = Curry._3(StateMap[/* add */3], start_state, initial_transitions, transitions);
  var next = function (s) {
    try {
      return flatten_transitions(Curry._2(StateMap[/* find */21], s, joint_transitions));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Nfa$ReasonReNfa.CharMap[/* empty */0];
      } else {
        throw exn;
      }
    }
  };
  return /* record */[
          /* start */start_state,
          /* finals */finals,
          /* next */next
        ];
}

function seq(l, r) {
  var exit = 0;
  if (typeof l === "number" && l !== 0) {
    return r;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (typeof r === "number" && r !== 0) {
      return l;
    } else {
      return /* Seq */Block.__(2, [
                l,
                r
              ]);
    }
  }
  
}

function alt(l, r) {
  if (typeof l === "number" || l.tag || typeof r === "number" || r.tag) {
    return /* Alt */Block.__(1, [
              l,
              r
            ]);
  } else {
    return /* Char */Block.__(0, [Curry._2(C[/* union */6], l[0], r[0])]);
  }
}

function star(r) {
  return /* Star */Block.__(3, [r]);
}

function plus(t) {
  return seq(t, /* Star */Block.__(3, [t]));
}

function chr(c) {
  return /* Char */Block.__(0, [Curry._1(C[/* singleton */4], c)]);
}

function opt(t) {
  return alt(t, /* Eps */1);
}

function range_(l, h) {
  var _i = l;
  var h$1 = h;
  var _acc = C[/* empty */0];
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i === h$1) {
      return Curry._2(C[/* add */3], Char.chr(i), acc);
    } else {
      _acc = Curry._2(C[/* add */3], Char.chr(i), acc);
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function range(l, h) {
  return /* Char */Block.__(0, [range_(l, h)]);
}

var h = Char.chr(255);

var l$1 = Char.chr(0);

var any = /* Char */Block.__(0, [range_(l$1, h)]);

var Parse_error = Caml_exceptions.create("Regex-ReasonReNfa.Parse_error");

var Fail = Caml_exceptions.create("Regex-ReasonReNfa.Parse.Fail");

function re_parse_atom(param) {
  if (param) {
    var h = param[0];
    var exit = 0;
    var switcher = h - 63 | 0;
    if (switcher > 61 || switcher < 0) {
      switch (switcher) {
        case -23 : 
            var match = re_parse_alt(param[1]);
            var match$1 = match[1];
            if (match$1) {
              if (match$1[0] !== 41) {
                throw Fail;
              } else {
                return /* tuple */[
                        match[0],
                        match$1[1]
                      ];
              }
            } else {
              throw Fail;
            }
        case -22 : 
        case -21 : 
        case -20 : 
            return undefined;
        case -19 : 
        case -18 : 
            exit = 1;
            break;
        case -17 : 
            return /* tuple */[
                    any,
                    param[1]
                  ];
        default:
          exit = 1;
      }
    } else if (switcher > 60 || switcher < 1) {
      return undefined;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              /* Char */Block.__(0, [Curry._1(C[/* singleton */4], h)]),
              param[1]
            ];
    }
    
  }
  
}

function re_parse_suffixed(s) {
  var match = re_parse_atom(s);
  if (match !== undefined) {
    var match$1 = match;
    var rest = match$1[1];
    var r = match$1[0];
    if (rest) {
      var switcher = rest[0] - 42 | 0;
      if (switcher === 0 || switcher === 1) {
        if (switcher !== 0) {
          return /* tuple */[
                  seq(r, /* Star */Block.__(3, [r])),
                  rest[1]
                ];
        } else {
          return /* tuple */[
                  /* Star */Block.__(3, [r]),
                  rest[1]
                ];
        }
      } else if (switcher !== 21) {
        return /* tuple */[
                r,
                rest
              ];
      } else {
        return /* tuple */[
                alt(r, /* Eps */1),
                rest[1]
              ];
      }
    } else {
      return /* tuple */[
              r,
              rest
            ];
    }
  }
  
}

function re_parse_seq(s) {
  var match = re_parse_suffixed(s);
  if (match !== undefined) {
    var match$1 = match;
    var match$2 = re_parse_seq(match$1[1]);
    return /* tuple */[
            seq(match$1[0], match$2[0]),
            match$2[1]
          ];
  } else {
    return /* tuple */[
            /* Eps */1,
            s
          ];
  }
}

function re_parse_alt(s) {
  var match = re_parse_seq(s);
  var rest = match[1];
  var r = match[0];
  if (rest && rest[0] === 124) {
    var match$1 = re_parse_alt(rest[1]);
    return /* tuple */[
            alt(r, match$1[0]),
            match$1[1]
          ];
  } else {
    return /* tuple */[
            r,
            rest
          ];
  }
}

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function parse(s) {
  var exit = 0;
  var val;
  try {
    val = re_parse_alt(explode(s));
    exit = 1;
  }
  catch (exn){
    if (exn === Fail) {
      throw [
            Parse_error,
            s
          ];
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (val[1]) {
      throw [
            Parse_error,
            s
          ];
    } else {
      return val[0];
    }
  }
  
}

var CharSet = $$Set.Make([Char.compare]);

function regexp2parseTree(regexp) {
  var re = parse(regexp);
  var unparse = function (r) {
    if (typeof r === "number") {
      if (r === 0) {
        return /* Leaf */Block.__(2, [
                  "Empty",
                  ""
                ]);
      } else {
        return /* Leaf */Block.__(2, [
                  "Eps",
                  ""
                ]);
      }
    } else {
      switch (r.tag | 0) {
        case 0 : 
            var s = r[0];
            var match = Curry._1(CharSet[/* cardinal */18], s);
            return /* Leaf */Block.__(2, [
                      "Char",
                      match === 0 || match === 1 ? (
                          match !== 0 ? $$String.make(1, Curry._1(CharSet[/* choose */22], s)) : "{}"
                        ) : (
                          match !== 256 ? "{" + ($$String.concat(" ", List.map((function (param) {
                                          return $$String.make(1, param);
                                        }), Curry._1(CharSet[/* elements */19], s))) + "}") : "."
                        )
                    ]);
        case 1 : 
            return /* Two */Block.__(1, [
                      "Alt",
                      unparse(r[0]),
                      unparse(r[1])
                    ]);
        case 2 : 
            return /* Two */Block.__(1, [
                      "Seq",
                      unparse(r[0]),
                      unparse(r[1])
                    ]);
        case 3 : 
            return /* One */Block.__(0, [
                      "Star",
                      unparse(r[0])
                    ]);
        
      }
    }
  };
  return unparse(re);
}

var Parse = /* module */[
  /* Fail */Fail,
  /* re_parse_atom */re_parse_atom,
  /* re_parse_suffixed */re_parse_suffixed,
  /* re_parse_seq */re_parse_seq,
  /* re_parse_alt */re_parse_alt,
  /* explode */explode,
  /* parse */parse,
  /* CharSet */CharSet,
  /* regexp2parseTree */regexp2parseTree
];

var eps = /* Eps */1;

var empty = /* Empty */0;

export {
  C ,
  Letter ,
  LetterSet ,
  Letter2Set ,
  l ,
  p ,
  d ,
  f_ ,
  StateMap ,
  CharSetMap ,
  add_transition2 ,
  add_transition ,
  transition_map_of_factor_set ,
  positions ,
  transition_map_of_letter_set ,
  fresh_state ,
  start_state ,
  annotate ,
  flatten_transitions ,
  compile ,
  seq ,
  alt ,
  star ,
  plus ,
  eps ,
  chr ,
  opt ,
  empty ,
  range_ ,
  range ,
  any ,
  Parse_error ,
  Parse ,
  parse ,
  regexp2parseTree ,
  
}
/* C Not a pure module */
