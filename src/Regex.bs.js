// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE

import * as $$Map from "../node_modules/bs-platform/lib/es6/map.js";
import * as $$Set from "../node_modules/bs-platform/lib/es6/set.js";
import * as Char from "../node_modules/bs-platform/lib/es6/char.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Int32 from "../node_modules/bs-platform/lib/es6/int32.js";
import * as Caml_obj from "../node_modules/bs-platform/lib/es6/caml_obj.js";
import * as Caml_string from "../node_modules/bs-platform/lib/es6/caml_string.js";
import * as Caml_exceptions from "../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as Nfa$ReasonReNfa from "./Nfa.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";

var C = $$Set.Make([Char.compare]);

function compare(param, param$1) {
  return Caml_obj.caml_compare(param[1], param$1[1]);
}

var Letter = /* module */[/* compare */compare];

var S = $$Set.Make(Letter);

var $less$plus$great = S[/* union */6];

function compare$1(param, param$1) {
  return Caml_obj.caml_compare(/* tuple */[
              param[0][1],
              param[1][1]
            ], /* tuple */[
              param$1[0][1],
              param$1[1][1]
            ]);
}

var Pair = /* module */[/* compare */compare$1];

var S$1 = $$Set.Make(Pair);

var $less$plus$great$1 = S$1[/* union */6];

function $great$great$eq(m, k) {
  return Curry._3(S[/* fold */13], (function (x, s) {
                return Curry._2($less$plus$great$1, Curry._1(k, x), s);
              }), m, S$1[/* empty */0]);
}

function $less$star$great(l, r) {
  return $great$great$eq(l, (function (x) {
                return $great$great$eq(r, (function (y) {
                              return Curry._1(S$1[/* singleton */4], /* tuple */[
                                          x,
                                          y
                                        ]);
                            }));
              }));
}

function l(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      if (param === 0) {
        return false;
      } else {
        return true;
      }
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return false;
        case 1 : 
            if (l(param[0])) {
              return true;
            } else {
              _param = param[1];
              continue ;
            }
        case 2 : 
            if (l(param[0])) {
              _param = param[1];
              continue ;
            } else {
              return false;
            }
        case 3 : 
            return true;
        
      }
    }
  };
}

function p(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return S[/* empty */0];
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return Curry._1(S[/* singleton */4], param[0]);
        case 1 : 
            return Curry._2($less$plus$great, p(param[0]), p(param[1]));
        case 2 : 
            var e = param[0];
            return Curry._2($less$plus$great, p(e), l(e) ? p(param[1]) : S[/* empty */0]);
        case 3 : 
            _param = param[0];
            continue ;
        
      }
    }
  };
}

function d(_param) {
  while(true) {
    var param = _param;
    if (typeof param === "number") {
      return S[/* empty */0];
    } else {
      switch (param.tag | 0) {
        case 0 : 
            return Curry._1(S[/* singleton */4], param[0]);
        case 1 : 
            return Curry._2($less$plus$great, d(param[0]), d(param[1]));
        case 2 : 
            var e = param[1];
            return Curry._2($less$plus$great, l(e) ? d(param[0]) : S[/* empty */0], d(e));
        case 3 : 
            _param = param[0];
            continue ;
        
      }
    }
  };
}

function f_(param) {
  if (typeof param === "number") {
    return S$1[/* empty */0];
  } else {
    switch (param.tag | 0) {
      case 1 : 
          return Curry._2($less$plus$great$1, f_(param[0]), f_(param[1]));
      case 2 : 
          var f = param[1];
          var e = param[0];
          return Curry._2($less$plus$great$1, Curry._2($less$plus$great$1, f_(e), f_(f)), $less$star$great(d(e), p(f)));
      case 3 : 
          var e$1 = param[0];
          return Curry._2($less$plus$great$1, f_(e$1), $less$star$great(d(e$1), p(e$1)));
      default:
        return S$1[/* empty */0];
    }
  }
}

var StateMap = $$Map.Make([Int32.compare]);

var CharSetMap = $$Map.Make([C[9]]);

function add_transition2(c, i, tm) {
  var ss;
  try {
    ss = Curry._2(CharSetMap[/* find */21], c, tm);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      ss = Nfa$ReasonReNfa.StateSet[/* empty */0];
    } else {
      throw exn;
    }
  }
  return Curry._3(CharSetMap[/* add */3], c, Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], i, ss), tm);
}

function transition_map_of_factor_set(fs) {
  return Curry._3(S$1[/* fold */13], (function (param, sm) {
                var match = param[1];
                var i1 = param[0][1];
                var c2 = match[0];
                var i2 = match[1];
                var sm$1 = sm;
                var tm;
                try {
                  tm = Curry._2(StateMap[/* find */21], i1, sm$1);
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    tm = CharSetMap[/* empty */0];
                  } else {
                    throw exn;
                  }
                }
                return Curry._3(StateMap[/* add */3], i1, add_transition2(c2, i2, tm), sm$1);
              }), fs, StateMap[/* empty */0]);
}

function positions(s) {
  return Curry._1(Nfa$ReasonReNfa.StateSet[/* of_list */25], List.map((function (prim) {
                    return prim[1];
                  }), Curry._1(S[/* elements */19], s)));
}

function transition_map_of_letter_set(s) {
  return Curry._3(S[/* fold */13], (function (param, tm) {
                var i = param[1];
                var c = param[0];
                var entry;
                var exit = 0;
                var s;
                try {
                  s = Curry._2(CharSetMap[/* find */21], c, tm);
                  exit = 1;
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    entry = Curry._1(Nfa$ReasonReNfa.StateSet[/* singleton */4], i);
                  } else {
                    throw exn;
                  }
                }
                if (exit === 1) {
                  entry = Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], i, s);
                }
                return Curry._3(CharSetMap[/* add */3], c, entry, tm);
              }), s, CharSetMap[/* empty */0]);
}

var counter = /* record */[/* contents */0];

function incr32(r) {
  r[0] = Int32.succ(r[0]);
  return /* () */0;
}

function fresh_state(param) {
  var c = counter[0];
  incr32(counter);
  return c;
}

var start_state = fresh_state(/* () */0);

function annotate(param) {
  if (typeof param === "number") {
    if (param === 0) {
      return /* Empty */0;
    } else {
      return /* Eps */1;
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          var p_000 = param[0];
          var p_001 = fresh_state(/* () */0);
          var p = /* tuple */[
            p_000,
            p_001
          ];
          return /* Char */Block.__(0, [p]);
      case 1 : 
          return /* Alt */Block.__(1, [
                    annotate(param[0]),
                    annotate(param[1])
                  ]);
      case 2 : 
          return /* Seq */Block.__(2, [
                    annotate(param[0]),
                    annotate(param[1])
                  ]);
      case 3 : 
          return /* Star */Block.__(3, [annotate(param[0])]);
      
    }
  }
}

function compile(r) {
  var r$1 = annotate(r);
  var finals = l(r$1) ? Curry._2(Nfa$ReasonReNfa.StateSet[/* add */3], start_state, positions(d(r$1))) : positions(d(r$1));
  var transitions = transition_map_of_factor_set(f_(r$1));
  var initial_transitions = transition_map_of_letter_set(p(r$1));
  var joint_transitions = Curry._3(StateMap[/* add */3], start_state, initial_transitions, transitions);
  var next = function (s) {
    try {
      var cm = Curry._2(StateMap[/* find */21], s, joint_transitions);
      return Curry._3(CharSetMap[/* fold */10], (function (cs, ss, cm) {
                    return Curry._3(C[/* fold */13], (function (c, cm) {
                                  var entry;
                                  try {
                                    entry = Curry._2(Nfa$ReasonReNfa.CharMap[/* find */21], c, cm);
                                  }
                                  catch (exn){
                                    if (exn === Caml_builtin_exceptions.not_found) {
                                      entry = Nfa$ReasonReNfa.StateSet[/* empty */0];
                                    } else {
                                      throw exn;
                                    }
                                  }
                                  return Curry._3(Nfa$ReasonReNfa.CharMap[/* add */3], c, Curry._2(Nfa$ReasonReNfa.StateSet[/* union */6], ss, entry), cm);
                                }), cs, cm);
                  }), cm, Nfa$ReasonReNfa.CharMap[/* empty */0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return Nfa$ReasonReNfa.CharMap[/* empty */0];
      } else {
        throw exn;
      }
    }
  };
  return /* record */[
          /* start */start_state,
          /* finals */finals,
          /* next */next
        ];
}

function seq(l, r) {
  return /* Seq */Block.__(2, [
            l,
            r
          ]);
}

function alt(l, r) {
  if (typeof l === "number" || l.tag || typeof r === "number" || r.tag) {
    return /* Alt */Block.__(1, [
              l,
              r
            ]);
  } else {
    return /* Char */Block.__(0, [Curry._2(C[/* union */6], l[0], r[0])]);
  }
}

function star(r) {
  return /* Star */Block.__(3, [r]);
}

function plus(t) {
  return /* Seq */Block.__(2, [
            t,
            /* Star */Block.__(3, [t])
          ]);
}

function chr(c) {
  return /* Char */Block.__(0, [Curry._1(C[/* singleton */4], c)]);
}

function opt(t) {
  return alt(t, /* Eps */1);
}

function range_(l, h) {
  var _i = l;
  var h$1 = h;
  var _acc = C[/* empty */0];
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i === h$1) {
      return Curry._2(C[/* add */3], Char.chr(i), acc);
    } else {
      _acc = Curry._2(C[/* add */3], Char.chr(i), acc);
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function range(l, h) {
  return /* Char */Block.__(0, [range_(l, h)]);
}

var any = range(Char.chr(0), Char.chr(255));

var Parse_error = Caml_exceptions.create("Regex-ReasonReNfa.Parse_error");

var Fail = Caml_exceptions.create("Regex-ReasonReNfa.Parse.Fail");

function re_parse_atom(param) {
  if (param) {
    var h = param[0];
    var exit = 0;
    var switcher = h - 63 | 0;
    if (switcher > 61 || switcher < 0) {
      switch (switcher) {
        case -23 : 
            var match = re_parse_alt(param[1]);
            var match$1 = match[1];
            if (match$1) {
              if (match$1[0] !== 41) {
                throw Fail;
              } else {
                return /* tuple */[
                        match[0],
                        match$1[1]
                      ];
              }
            } else {
              throw Fail;
            }
        case -22 : 
        case -21 : 
        case -20 : 
            return undefined;
        case -19 : 
        case -18 : 
            exit = 1;
            break;
        case -17 : 
            return /* tuple */[
                    any,
                    param[1]
                  ];
        default:
          exit = 1;
      }
    } else if (switcher > 60 || switcher < 1) {
      return undefined;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* tuple */[
              chr(h),
              param[1]
            ];
    }
    
  }
  
}

function re_parse_suffixed(s) {
  var match = re_parse_atom(s);
  if (match !== undefined) {
    var match$1 = match;
    var rest = match$1[1];
    var r = match$1[0];
    if (rest) {
      var switcher = rest[0] - 42 | 0;
      if (switcher === 0 || switcher === 1) {
        if (switcher !== 0) {
          return /* tuple */[
                  /* Seq */Block.__(2, [
                      r,
                      /* Star */Block.__(3, [r])
                    ]),
                  rest[1]
                ];
        } else {
          return /* tuple */[
                  /* Star */Block.__(3, [r]),
                  rest[1]
                ];
        }
      } else if (switcher !== 21) {
        return /* tuple */[
                r,
                rest
              ];
      } else {
        return /* tuple */[
                alt(r, /* Eps */1),
                rest[1]
              ];
      }
    } else {
      return /* tuple */[
              r,
              rest
            ];
    }
  }
  
}

function re_parse_seq(s) {
  var match = re_parse_suffixed(s);
  if (match !== undefined) {
    var match$1 = match;
    var match$2 = re_parse_seq(match$1[1]);
    return /* tuple */[
            /* Seq */Block.__(2, [
                match$1[0],
                match$2[0]
              ]),
            match$2[1]
          ];
  } else {
    return /* tuple */[
            /* Eps */1,
            s
          ];
  }
}

function re_parse_alt(s) {
  var match = re_parse_seq(s);
  var rest = match[1];
  var r = match[0];
  if (rest && rest[0] === 124) {
    var match$1 = re_parse_alt(rest[1]);
    return /* tuple */[
            alt(r, match$1[0]),
            match$1[1]
          ];
  } else {
    return /* tuple */[
            r,
            rest
          ];
  }
}

function explode(s) {
  var _i = s.length - 1 | 0;
  var _l = /* [] */0;
  while(true) {
    var l = _l;
    var i = _i;
    if (i < 0) {
      return l;
    } else {
      _l = /* :: */[
        Caml_string.get(s, i),
        l
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function parse(s) {
  var exit = 0;
  var val;
  try {
    val = re_parse_alt(explode(s));
    exit = 1;
  }
  catch (exn){
    if (exn === Fail) {
      throw [
            Parse_error,
            s
          ];
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    if (val[1]) {
      throw [
            Parse_error,
            s
          ];
    } else {
      return val[0];
    }
  }
  
}

var empty = /* Empty */0;

var eps = /* Eps */1;

export {
  empty ,
  eps ,
  any ,
  range ,
  chr ,
  seq ,
  alt ,
  opt ,
  star ,
  plus ,
  parse ,
  compile ,
  Parse_error ,
  
}
/* C Not a pure module */
