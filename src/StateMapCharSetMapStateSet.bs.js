// Generated by BUCKLESCRIPT VERSION 4.0.8, PLEASE EDIT WITH CARE

import * as $$Map from "../node_modules/bs-platform/lib/es6/map.js";
import * as List from "../node_modules/bs-platform/lib/es6/list.js";
import * as $$Array from "../node_modules/bs-platform/lib/es6/array.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Int32 from "../node_modules/bs-platform/lib/es6/int32.js";
import * as $$String from "../node_modules/bs-platform/lib/es6/string.js";
import * as Caml_array from "../node_modules/bs-platform/lib/es6/caml_array.js";
import * as CharSet$ReasonReNfa from "./CharSet.bs.js";
import * as StateSet$ReasonReNfa from "./StateSet.bs.js";
import * as CharSetSet$ReasonReNfa from "./CharSetSet.bs.js";
import * as Caml_builtin_exceptions from "../node_modules/bs-platform/lib/es6/caml_builtin_exceptions.js";
import * as CharSetMapStateSet$ReasonReNfa from "./CharSetMapStateSet.bs.js";

var include = $$Map.Make([Int32.compare]);

var singleton = include[4];

var fold = include[10];

var bindings = include[16];

var find = include[21];

function to_string(state_map) {
  return "{" + ($$String.concat(",", List.rev(Curry._3(fold, (function (state, char_set, l) {
                          return /* :: */[
                                  Int32.to_string(state) + (":" + CharSetMapStateSet$ReasonReNfa.to_string(char_set)),
                                  l
                                ];
                        }), state_map, /* [] */0))) + "}");
}

function example(state, char_list, state_list) {
  return Curry._2(singleton, state, CharSetMapStateSet$ReasonReNfa.example(char_list, state_list));
}

function test(param) {
  var abc = example(0, /* :: */[
        /* "a" */97,
        /* [] */0
      ], /* :: */[
        1,
        /* [] */0
      ]);
  if (to_string(abc) === "{0:{a:{1}}}") {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "StateMapCharSetMapStateSet.re",
            21,
            2
          ]
        ];
  }
}

function to_matrix(state_map) {
  var char_sets = $$Array.of_list(Curry._1(CharSetSet$ReasonReNfa.elements, Curry._3(fold, (function (param, char_set_map, char_set_set) {
                  return Curry._2(CharSetSet$ReasonReNfa.union, Curry._1(CharSetSet$ReasonReNfa.of_list, List.map((function (param) {
                                        return param[0];
                                      }), Curry._1(CharSetMapStateSet$ReasonReNfa.bindings, char_set_map))), char_set_set);
                }), state_map, CharSetSet$ReasonReNfa.empty)));
  var states = $$Array.of_list(List.map((function (param) {
              return param[0];
            }), Curry._1(bindings, state_map)));
  var dimx = states.length;
  var dimy = char_sets.length;
  var matrix = $$Array.make_matrix(dimx + 1 | 0, dimy + 1 | 0, "");
  for(var x = 1; x <= dimx; ++x){
    Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, x), 0, Int32.to_string(Caml_array.caml_array_get(states, x - 1 | 0)));
    for(var y = 1; y <= dimy; ++y){
      if (x === 1) {
        Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, 0), y, CharSet$ReasonReNfa.to_string(Caml_array.caml_array_get(char_sets, y - 1 | 0)));
      }
      var tmp;
      var exit = 0;
      var state_set;
      try {
        state_set = Curry._2(CharSetMapStateSet$ReasonReNfa.find, Caml_array.caml_array_get(char_sets, y - 1 | 0), Curry._2(find, Caml_array.caml_array_get(states, x - 1 | 0), state_map));
        exit = 1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          tmp = "";
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        tmp = StateSet$ReasonReNfa.to_string(state_set);
      }
      Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, x), y, tmp);
    }
  }
  return matrix;
}

var empty = include[0];

var is_empty = include[1];

var mem = include[2];

var add = include[3];

var remove = include[5];

var merge = include[6];

var compare = include[7];

var equal = include[8];

var iter = include[9];

var for_all = include[11];

var exists = include[12];

var filter = include[13];

var partition = include[14];

var cardinal = include[15];

var min_binding = include[17];

var max_binding = include[18];

var choose = include[19];

var split = include[20];

var map = include[22];

var mapi = include[23];

export {
  empty ,
  is_empty ,
  mem ,
  add ,
  singleton ,
  remove ,
  merge ,
  compare ,
  equal ,
  iter ,
  fold ,
  for_all ,
  exists ,
  filter ,
  partition ,
  cardinal ,
  bindings ,
  min_binding ,
  max_binding ,
  choose ,
  split ,
  find ,
  map ,
  mapi ,
  to_string ,
  example ,
  test ,
  to_matrix ,
  
}
/* include Not a pure module */
